(in-package :one-more-re-nightmare)

(define-type (literal set)
  :printer ((literal set)
            (let ((es (elements set)))
              (case (length es)
                (0
                 (if (typep set 'negative-symbol-set)
                     (write-char #\Σ stream)
                     (write-char #\ø stream)))
                (1
                 (if (typep set 'negative-symbol-set)
                     (format stream "(¬~a)" (first es))
                     (format stream "~a" (first es))))
                (otherwise
                 (format stream "~a" set))))))

(defun empty-set ()
  (literal (symbol-set)))
(defun universal-set ()
  (literal (set-inverse (symbol-set))))
(trivia:defpattern empty-set ()
  `(trivia:guard (literal set)
                 (set-null set)))

(define-type (empty-string)
  :printer (_ (write-string "ε" stream)))
(define-type (kleene r)
  :simplify (((kleene (kleene r)) (kleene r))
             ((kleene (empty-set)) (empty-string)))
  :printer ((kleene r)
            (format stream "[~a]*" r)))
(define-type (tag-set substitutions)
  :printer ((tag-set s)
            (format stream "[~{~a ← ~a~^, ~}]"
                    (loop for (variable replica source) in s
                          if (zerop replica)
                            collect variable
                          else
                            collect (format nil "~a_~a" variable replica)
                          collect (if (eql source 'position)
                                      "P"
                                      (format nil "~{~a_~a~}" source))))))
                  

(define-type (either r s)
  :simplify (((either r s)
              (if (eq r s)
                  r
                  (trivia.next:next)))
             ((either r s)
              (if (eq (remove-tags r) (remove-tags s))
                  r
                  (trivia.next:next)))
             ((either (either r s) q)
              (if (eq s q)
                  (either r q)
                  (trivia.next:next)))
             ((either (either s r) q)
              (if (eq s q)
                  (either r q)
                  (trivia.next:next)))
             ((either q (either r s))
              (if (eq s q)
                  (either r q)
                  (trivia.next:next)))
             ((either q (either s r))
              (if (eq s q)
                  (either r q)
                  (trivia.next:next)))
             ((either (empty-set) r) r)
             ((either r (empty-set)) r)
             ((either (literal s1) (literal s2))
              (literal (set-union s1 s2))))
  :printer ((either r s)
            (format stream "(~a) ∪ (~a)" r s)))
(define-type (both r s)
  :simplify (((both r s)
              (if (eq r s)
                  r
                  (trivia.next:next)))
             ((both _ (empty-set)) (empty-set))
             ((both (empty-set) _) (empty-set))
             ((both (tag-set s1) (tag-set s2))
              (tag-set (merge-tag-sets s1 s2)))
             ((both (tag-set s) (empty-string))
              (tag-set s))
             ((both (empty-string) (tag-set s))
              (tag-set s))
             ((both (literal s1) (literal s2))
              (literal (set-intersection s1 s2))))
  :printer ((both r s)
            (format stream "(~a) ∩ (~a)" r s)))
(define-type (invert r)
  :simplify (((invert (invert r)) r)
             ((invert (literal set))
              (literal (set-inverse set)))
             ((invert (empty-string)) (empty-set)))
  :printer ((invert r)
            (format stream "¬[~a]" r)))
(define-type (join r s)
  :simplify (((join (empty-set) _) (empty-set))
             ((join _ (empty-set)) (empty-set))
             ((join (empty-string) r) r)
             ((join r (empty-string)) r)
             ((join (tag-set s) (either p r))
              (either (join (tag-set s) p)
                      (join (tag-set s) r)))
             ((join (tag-set s1) (join (tag-set s2) r))
              (join (tag-set (merge-tag-sets s1 s2)) r))
             ((join (tag-set s1) (tag-set s2))
              (tag-set (merge-tag-sets s1 s2))))
  :printer ((join r s)
            (format stream "~a~a" r s)))

(defun text (vector)
  (reduce #'join (map 'vector (lambda (e)
                                (literal (symbol-set e)))
                      vector)
          :initial-value (empty-string) 
          :from-end t))

(defun group (r n)
  (join (tag-set `((,n 0 position)))
        (join r
              (tag-set `((,(1+ n) 0 position))))))
