(in-package :one-more-re-nightmare)

(defvar *broadcasts*)
(defun find-broadcast (value)
  (or (gethash value *broadcasts*)
      (setf (gethash value *broadcasts*)
            (make-symbol (format nil "BROADCAST-~d" value)))))

(trivia:defun-ematch translate-scalar-code (code)
  "Translate some 'scalar' code generated by MAKE-TEST-FORM into a vectorised computation."
  ('t   :always)
  ('nil :never)
  ;; All the Boolean operators just map over their arguments.
  ((list 'not thing)
   `(one-more-re-nightmare.vector-primops:v-not
     ,(translate-scalar-code thing)))
  ((list* 'or things)
   `(one-more-re-nightmare.vector-primops:v-or
     ,@(mapcar #'translate-scalar-code things)))
  ;; Ditto for = really.
  ((list '= value variable)
   `(one-more-re-nightmare.vector-primops:v32=
     ,(find-broadcast value) ,variable))
  ;; Generating good code for <= is tricky though. Whoever designed
  ;; SSE2 and AVX2 decided that just having = and > were good enough,
  ;; so we need an efficient implementation of ≤ from those.
  ((list '<= 0 value high)
   ;; No lower bounds here. Note that X ≤ N ⇔ N + 1 > X
   `(one-more-re-nightmare.vector-primops:v32> ,(find-broadcast (1+ high)) ,value))
  ((list '<= low value high)
   `(one-more-re-nightmare.vector-primops:v-and
     ;; Similarly, N ≤ X ⇔ X > N - 1
     (one-more-re-nightmare.vector-primops:v32> ,value ,(find-broadcast (1- low)))
     (one-more-re-nightmare.vector-primops:v32> ,(find-broadcast (1+ high)) ,value))))

(defun test-from-isum (variable isum)
  (translate-scalar-code (make-test-form isum variable '<= '=)))

(defun code-from-prefix (prefix)
  (assert (not (null prefix)) () "Why /even bother/ with a zero-length prefix?")
  (let ((tests '())
        (loads '())
        (assignments '())
        (n 0))
    (dolist (part prefix)
      (trivia:ematch part
        ((list :literal isum)
         (let ((name (make-symbol (format nil "LOAD-~d" n))))
           (trivia:ematch (test-from-isum name isum)
             (:always)
             (:never (error "This should never happen - the empty set has no prefix!"))
             (test
              (push `(,name (one-more-re-nightmare.vector-primops:v-load
                             vector
                             (the fixnum (+ ,n start))))
                    loads)
              (push test tests))))
         (incf n))
        ((list :tags tags)
         (push `(let ((position (the fixnum (+ ,n start))))
                  ,@(setf-from-assignments tags))
               assignments))))
    (values
     (reduce (lambda (a b) `(one-more-re-nightmare.vector-primops:v-and ,a ,b))
             tests)
     loads
     `(progn ,@(reverse assignments))
     n)))
