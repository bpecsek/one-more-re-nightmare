(in-package :one-more-re-nightmare)

(define-type (literal set))

(defun empty-set ()
  (literal (symbol-set)))
(defun universal-set ()
  (literal (set-inverse (symbol-set))))
(trivia:defpattern empty-set ()
  `(trivia:guard (literal set)
                 (set-null set)))

(define-type (empty-string)) ;; Îµ
(define-type (join r s)
             :simplify (((join (empty-set) _) (empty-set))
                        ((join _ (empty-set)) (empty-set))
                        ((join (empty-string) r) r)
                        ((join r (empty-string)) r))
             :hash-cons (((join (join r s) t) (join r (join s t)))))
(define-type (kleene r)
             :simplify (((kleene (kleene r)) (kleene r))
                        ((kleene (empty-set)) (empty-string))))
(define-type (either r s)
             :simplify (((either r s)
                         (if (eq r s)
                             r
                             (trivia.next:next)))
                        ((either (either r s) q)
                         (if (eq s q)
                             (either r q)
                             (trivia.next:next)))
                        ((either (either s r) q)
                         (if (eq s q)
                             (either r q)
                             (trivia.next:next)))
                        ((either q (either r s))
                         (if (eq s q)
                             (either r q)
                             (trivia.next:next)))
                        ((either q (either s r))
                         (if (eq s q)
                             (either r q)
                             (trivia.next:next)))
                        ((either (empty-set) r) r)
                        ((either r (empty-set)) r)
                        ((either (literal s1) (literal s2))
                         (literal (set-union s1 s2))))
             :hash-cons (((either (either r s) q) (either r (either s q)))
                         ((either r s) (either s r))))
(define-type (both r s)
             :simplify (((both r s)
                         (if (eq r s)
                             r
                             (trivia.next:next)))
                        ((both (literal s1) (literal s2))
                         (literal (set-intersection s1 s2))))
             :hash-cons (((both r s) (both s r))))
(define-type (invert r)
             :simplify (((invert (invert r)) r)
                        ((invert (literal set))
                         (literal (set-inverse set)))
                        ((invert (empty-string)) (empty-set))))
(define-type (start-group n))
(define-type (end-group n))
(defun group (r n)
  (join (start-group n)
        (join r
              (end-group n))))

(defun text (vector)
  (reduce #'join (map 'vector (lambda (e)
                                (literal (symbol-set e)))
                      vector)
          :initial-value (empty-string) 
          :from-end t))
