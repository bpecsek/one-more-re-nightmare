(in-package :one-more-re-nightmare)

(defvar *group-starts*)
(defvar *group-ends*)

(defun %derivative (re set prefix?)
  "Compute the derivative of a regular expression with regards to the set (i.e. the regular expression should be matched after a character in the set is matched)."
  (trivia:ematch re
    ((empty-string) (empty-set))
    ((start-group n)
     (when prefix?
       (push n *group-starts*))
     (empty-set))
    ((end-group n)
     (when prefix?
       (push n *group-ends*))
     (empty-set))
    ((literal matching-set)
     (if (set-null (set-intersection matching-set set))
         (empty-set)
         (empty-string)))
    ((join r s)
     (let* ((r* (%derivative r set prefix?))
            (s* (%derivative s set (and prefix? (prefix s)))))
       (if (nullable r)
           (either (join r* s) s*)
           (join r* s))))
    ((kleene r)
     (join (%derivative r set prefix?) (kleene r)))
    ((either r s)
     (either (%derivative r set prefix?)
             (%derivative s set prefix?)))
    ((both r s)
     (both (%derivative r set prefix?)
           (%derivative s set prefix?)))
    ((invert r) (invert (%derivative r set prefix?)))))

(defun derivative (re set)
  (let* ((*group-starts* '())
         (*group-ends* '())
         (d (%derivative re set t)))
    (trivia:match d
      ((or (end-group _)
           (start-group _))
       (setf d (empty-string))))
    (values d *group-starts* *group-ends*)))
