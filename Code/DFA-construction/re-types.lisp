(in-package :one-more-re-nightmare)

(define-type (literal set)
  :printer ((literal set)
            (let ((es (elements set)))
              (case (length es)
                (0
                 (if (typep set 'negative-symbol-set)
                     (write-char #\Σ stream)
                     (write-char #\ø stream)))
                (1
                 (if (typep set 'negative-symbol-set)
                     (format stream "(¬~a)" (first es))
                     (format stream "~a" (first es))))
                (otherwise
                 (format stream "~a" set))))))

(defun empty-set ()
  (literal (symbol-set)))
(defun universal-set ()
  (literal (set-inverse (symbol-set))))
(trivia:defpattern empty-set ()
  (alexandria:with-gensyms (set)
    `(trivia:guard (literal ,set)
                   (set-null ,set))))

(defvar *subscripts* "₀₁₂₃₄₅₆₇₈₉")
(defun subscripts (number)
  (map 'string
       (lambda (char)
         (aref *subscripts* (digit-char-p char)))
       (princ-to-string number)))

(define-type (empty-string)
  :printer (_ (write-string "ε" stream)))
(define-type (kleene r)
  :simplify (((kleene (kleene r)) (kleene r))
             ((kleene (empty-set)) (empty-string)))
  :printer ((kleene r)
            (format stream "[~a]*" r)))

(define-type (tag-set substitutions)
  :simplify (((tag-set (list))
              (empty-string)))
  :printer ((tag-set s)
            (format stream "{~{~a ← ~a~^, ~}}"
                    (loop for (variable replica source) in s
                          if (zerop replica)
                            collect variable
                          else
                            collect (format nil "~a~a"
                                            variable
                                            (subscripts replica))
                          collect (if (eql source 'position)
                                      "P"
                                      (format nil "~a~a"
                                              (first source)
                                              (subscripts (second source))))))))
(define-type (alpha expression history)
  :simplify (((alpha (empty-set) (empty-set)) (empty-set)))
  :printer ((alpha r n)
            (format stream "α[~@<~a, ~_~a]~:>" r n)))
(define-type (grep match-vector prototype)
  :simplify (((grep r _)
              (if (eq (nullable r) (empty-set))
                  (trivia.next:next)
                  r))
             ((grep (empty-set) _)
              (empty-set)))
  :printer ((grep r _)
            (format stream "γ[~a]" r)))

(define-type (either r s)
  :simplify (((either (either p r) s)
              (either p (either r s)))
             ((either (empty-set) r) r)
             ((either r (empty-set)) r)
             ((either (literal s1) (literal s2))
              (literal (set-union s1 s2)))
             ((either r s)
              (scan-either-for-duplicates r s)))
  :printer ((either r s)
            (format stream "~@<(~a) ∪ ~_(~a)~:>" r s)))

(defun scan-either-for-duplicates (r s)
  (labels ((e (r s)
             (cond
               ((eq s (empty-set))
                r)
               ((eq r (empty-set))
                s)
               (t (%either r s))))
           (scan (rhs)
             (trivia:match rhs
               ((either lhs next-rhs)
                (if (eq (remove-tags lhs) (remove-tags r))
                    next-rhs
                    (e lhs (scan next-rhs))))
               (_
                (if (eq (remove-tags rhs) (remove-tags r))
                    (empty-set)
                    rhs)))))
    (e r (scan s))))

(define-type (both r s)
  :simplify (((both r s)
              (if (eq r s)
                  r
                  (trivia.next:next)))
             ((both _ (empty-set)) (empty-set))
             ((both (empty-set) _) (empty-set))
             ((both (tag-set s1) (tag-set s2))
              (tag-set (merge-tag-sets s1 s2)))
             ((both (tag-set s) (empty-string))
              (tag-set s))
             ((both (empty-string) (tag-set s))
              (tag-set s))
             ((both (literal s1) (literal s2))
              (literal (set-intersection s1 s2))))
  :printer ((both r s)
            (format stream "(~a) ∩ (~a)" r s)))
(define-type (invert r)
  :simplify (((invert (invert r)) r)
             ((invert (literal set))
              (literal (set-inverse set)))
             ((invert (empty-string)) (empty-set)))
  :printer ((invert r)
            (format stream "¬[~a]" r)))
(define-type (join r s)
  :simplify (((join (empty-set) _) (empty-set))
             ((join _ (empty-set)) (empty-set))
             ((join (empty-string) r) r)
             ((join r (empty-string)) r)
             ((join (tag-set s) (either p r))
              (either (join (tag-set s) p)
                      (join (tag-set s) r)))
             ((join (join (tag-set s1) r) s)
              ;; Rotate so that a TAG-SET is always at the start.
              (join (tag-set s1) (join r s)))
             ((join (tag-set s1) (join (tag-set s2) r))
              (join (tag-set (merge-tag-sets s1 s2)) r))
             ((join (tag-set s1) (tag-set s2))
              (tag-set (merge-tag-sets s1 s2))))
  :printer ((join r s)
            (format stream "~a~a" r s)))

(defun text (vector)
  (reduce #'join (map 'vector (lambda (e)
                                (literal (symbol-set e)))
                      vector)
          :initial-value (empty-string) 
          :from-end t))

(defun group (r n)
  (join (tag-set `((,(1- (* 2 n)) 0 position)))
        (join r
              (tag-set `((,(* 2 n) 0 position))))))
